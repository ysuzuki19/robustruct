package tmpl

import (
	"bytes"
	"text/template"
)

type TemplateCollector struct {
	buf bytes.Buffer
	err error
}

func NewTemplateCollector() *TemplateCollector {
	var buf bytes.Buffer
	return &TemplateCollector{
		buf: buf,
		err: nil,
	}
}

func (tc *TemplateCollector) Merge(tmpl string, args interface{}) *TemplateCollector {
	if tc.err != nil {
		return tc
	}

	t, err := template.New("tmpl").Funcs(
		template.FuncMap{
			"capitalize": capitalize,
			"bracket":    Bracket,
			"csvConnect": csvConnect,
		},
	).Parse(tmpl)
	if err != nil {
		tc.err = err
	}

	if err := t.Execute(&tc.buf, args); err != nil {
		tc.err = err
	}

	return tc
}

func (tc *TemplateCollector) Export() ([]byte, error) {
	if tc.err != nil {
		return nil, tc.err
	}
	return tc.buf.Bytes(), nil
}

const Header = `
// Code generated by senum; DO NOT EDIT.
package {{ .Package }}
`

const Tag = `
type tag int
const (
{{- range $variant := .Variants }}
    tag{{ $variant.Name | capitalize }} tag = iota
{{- end }}
)
`

const Enum = `
type {{ .EnumDefName }} struct {
    {{ .Package }}{{.UseTypeParams | bracket}}
    tag tag
}
`

const New = `
{{- range $variant := .Variants }}
func New{{ $variant.Name | capitalize }}{{$.DefTypeParams | bracket}}({{ if $variant.HasData }}v {{ $variant.TypeName }}{{ end }}) {{ $.EnumUseName }} {
    return {{ $.EnumUseName }}{
        {{ $.Package }}: {{ $.Package }}{{ $.UseTypeParams | bracket }}{
            {{ $variant.FieldName }}: {{ if $variant.HasData }}v{{ else }}nil{{ end }},
        },
        tag: tag{{ $variant.Name | capitalize }},
    }
}
{{- end }}
`

const Is = `
{{- range $variant := .Variants }}
func (e *{{ $.EnumUseName }}) Is{{ $variant.Name | capitalize }}() bool {
    return e.tag == tag{{ $variant.Name | capitalize }}
}
{{- end }}
`

const As = `
{{- range $variant := .Variants }}
{{- if $variant.HasData }}
func (e *{{ $.EnumUseName }}) As{{ $variant.Name | capitalize }}() ({{ $variant.TypeName }}, bool) {
    if e.Is{{ $variant.Name | capitalize }}() {
        return e.{{ $.Package }}.{{ $variant.FieldName }}, true
    }
    return nil, false
}
{{- end }}
{{- end }}
`

const Switch = `
type Switcher{{.DefTypeParams | bracket}} struct {
{{- range $variant := .Variants }}
    {{ $variant.Name | capitalize }} func({{ if $variant.HasData }}v {{ $variant.TypeName }}{{ end }})
{{- end }}
}

func (e *{{ $.EnumUseName }}) Switch(s Switcher{{.UseTypeParams | bracket}}) {
    switch e.tag {
    {{- range $variant := .Variants }}
    case tag{{ $variant.Name | capitalize }}:
        {{- if $variant.HasData }}
        s.{{ $variant.Name | capitalize }}(e.{{ $.Package }}.{{ $variant.FieldName }})
        {{- else }}
        s.{{ $variant.Name | capitalize }}()
        {{- end }}
    {{- end }}
    }
}
`

const Match = `
type Matcher[MatchResult any {{.DefTypeParams | csvConnect}}] struct {
{{- range $variant := .Variants }}
    {{ $variant.Name | capitalize }} func({{ if $variant.HasData }}v {{ $variant.TypeName }}{{ end }}) MatchResult
{{- end }}
}

func Match[MatchResult any {{.DefTypeParams | csvConnect}}](e *{{ .EnumUseName }}, m Matcher[MatchResult {{.UseTypeParams | csvConnect}}]) MatchResult {
    switch e.tag {
    {{- range $variant := .Variants }}
    case tag{{ $variant.Name | capitalize }}:
        {{- if $variant.HasData }}
        return m.{{ $variant.Name | capitalize }}(e.{{ $.Package }}.{{ $variant.FieldName }})
        {{- else }}
        return m.{{ $variant.Name | capitalize }}()
        {{- end }}
    {{- end }}
    }
    panic("unreachable: invalid tag")
}
`
