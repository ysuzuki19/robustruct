package process

import (
	"fmt"
	"strings"

	"github.com/ysuzuki19/robustruct/cmd/exp/senumgen/internal/process/coder"
)

type GenerateArgs struct {
	DirPath       string
	Name          string
	AnalyzeResult AnalyzeResult
}

func Generate(args GenerateArgs) ([]byte, error) {
	defTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return fmt.Sprintf("%s %s", tp.Name, tp.TypeName)
		}),
		", ",
	)

	useTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return tp.Name
		}),
		", ",
	)

	templateData := struct {
		Package       string
		DefTypeParams string
		UseTypeParams string
		EnumDefName   string
		EnumUseName   string
		Variants      []Variant
	}{
		Package:       args.Name,
		DefTypeParams: defTypeParams,
		UseTypeParams: useTypeParams,
		EnumDefName:   fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), coder.Bracket(defTypeParams)),
		EnumUseName:   fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), coder.Bracket(useTypeParams)),
		Variants:      args.AnalyzeResult.Variants,
	}

	c := coder.New().Globals(coder.Vars{
		"Package":       templateData.Package,
		"DefTypeParams": templateData.DefTypeParams,
		"UseTypeParams": templateData.UseTypeParams,
		"EnumDefName":   templateData.EnumDefName,
		"EnumUseName":   templateData.EnumUseName,
	})

	c.
		// package declaration
		Str(`
// Code generated by senum; DO NOT EDIT.`).
		Format(`
package %s`, templateData.Package).LF().

		// enum tag
		Str(`
type tag int`).LF().
		Wrap("const (", ")", func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				c.Format("tag%s tag = iota", coder.Capitalize(variant.Name)).LF()
			}
		}).
		Format(`
type %s struct {
    %s%s
    tag tag
}`, templateData.EnumDefName, templateData.Package, coder.Bracket(templateData.UseTypeParams)).LF().

		// enum constructor
		Func(func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				c.Tmpl(`
func New{{ .FieldName | capitalize }}{{ .DefTypeParams | bracket }}({{ if .HasData }}v {{ .TypeName }}{{ end }}) {{ .EnumUseName }} {
	return {{ .EnumUseName }}{
			{{ .Package }}: {{ .Package }}{{ .UseTypeParams | bracket }}{
					{{ .FieldName }}: {{ if .HasData }}v{{ else }}nil{{ end }},
			},
			tag: tag{{ .FieldName | capitalize }},
	}
}`, coder.Vars{
					"FieldName": variant.FieldName,
					"TypeName":  variant.TypeName,
					"HasData":   variant.HasData,
				})
			}
		}).LF().

		// enum Is{FieldName} method
		Func(func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				c.Tmpl(`
func (e *{{ .EnumUseName }}) Is{{ .Name }}() bool {
	return e.tag == tag{{ .Name }}
}`, coder.Vars{
					"Name": coder.Capitalize(variant.Name),
				})
			}
		}).LF().

		// enum As{FieldName} method
		Func(func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				if variant.HasData {
					c.Tmpl(`
func (e *{{ .EnumUseName }}) As{{ .FieldName | capitalize }}() ({{ .TypeName }}, bool) {
	if e.Is{{ .FieldName | capitalize }}() {
		return e.{{ .Package }}.{{ .FieldName }}, true
	}
	return nil, false
}`, coder.Vars{
						"FieldName": variant.FieldName,
						"TypeName":  variant.TypeName,
					})
				}
			}
		}).LF().

		// enum Switcher struct
		Format(`type Switcher%s struct`, coder.Bracket(templateData.DefTypeParams)).
		Block(func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				c.LF().Format(" %s func", coder.Capitalize(variant.Name)).Parens(func(c *coder.Coder) {
					if variant.HasData {
						c.Str("v " + variant.TypeName)
					}
				})
			}
		}).LF().

		// enum Switch method
		Tmpl("func(e *{{ .EnumUseName }})Switch").
		Parens(func(c *coder.Coder) {
			c.Str("s Switcher")
			if templateData.UseTypeParams != "" {
				c.Format("[%s]", templateData.UseTypeParams)
			}
		}).
		Block(func(c *coder.Coder) {
			c.Str("switch e.tag").Braces(func(c *coder.Coder) {
				for _, variant := range templateData.Variants {
					c.LF().Format("case tag%s:", coder.Capitalize(variant.Name))
					if variant.HasData {
						c.Str("s.").Capitalize(variant.Name).Parens(func(c *coder.Coder) {
							c.Format("e.%s.%s", templateData.Package, variant.FieldName)
						})
					} else {
						c.Str("s.").Capitalize(variant.Name).Str("()")
					}
				}
			})
		}).LF().

		// Matcher struct
		Tmpl(`type Matcher[MatchResult any {{.DefTypeParams | csvConnect}}] struct`).
		Block(func(c *coder.Coder) {
			for _, variant := range templateData.Variants {
				c.Format("%s func", coder.Capitalize(variant.Name)).Parens(func(c *coder.Coder) {
					if variant.HasData {
						c.Str("v " + variant.TypeName)
					}
				}).Str(" MatchResult").LF()
			}
		}).LF().
		Tmpl(`func Match[MatchResult any {{.DefTypeParams | csvConnect}}](e *{{ .EnumUseName }}, m Matcher[MatchResult {{.UseTypeParams | csvConnect}}]) MatchResult`).
		Block(func(c *coder.Coder) {
			c.Format("switch e.tag").Braces(func(c *coder.Coder) {
				for _, variant := range templateData.Variants {
					c.
						Format("case tag%s:", coder.Capitalize(variant.Name)).
						Format("return m.%s", coder.Capitalize(variant.Name)).Parens(func(c *coder.Coder) {
						if variant.HasData {
							c.Format("e.%s.%s", templateData.Package, variant.FieldName)
						}
					}).LF()
				}
			}).LF().Str("panic(\"unreachable: invalid tag\")")
		})

	generated, err := c.Export()
	if err != nil {
		return nil, err
	}
	fmt.Println(string(generated))

	return generated, nil
}
