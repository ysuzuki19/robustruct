package process

import (
	"fmt"
	"strings"

	code_collector "github.com/ysuzuki19/robustruct/cmd/exp/senumgen/internal/process/code_collector"
)

type GenerateArgs struct {
	DirPath       string
	Name          string
	AnalyzeResult AnalyzeResult
}

func Generate(args GenerateArgs) ([]byte, error) {
	defTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return fmt.Sprintf("%s %s", tp.Name, tp.TypeName)
		}),
		", ",
	)

	useTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return tp.Name
		}),
		", ",
	)

	templateData := struct {
		Package       string
		DefTypeParams string
		UseTypeParams string
		EnumDefName   string
		EnumUseName   string
		Variants      []Variant
	}{
		Package:       args.Name,
		DefTypeParams: defTypeParams,
		UseTypeParams: useTypeParams,
		EnumDefName:   fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), code_collector.Bracket(defTypeParams)),
		EnumUseName:   fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), code_collector.Bracket(useTypeParams)),
		Variants:      args.AnalyzeResult.Variants,
	}

	cc := code_collector.NewCodeCollector()

	cc.
		Str(`
// Code generated by senum; DO NOT EDIT.`).
		Format(`
package %s`, templateData.Package).LF().
		Str(`
type tag int`).LF().
		Func(func(cc *code_collector.CodeCollector) *code_collector.CodeCollector {
			cc.Str("const (")
			defer cc.Str(")")
			for _, variant := range templateData.Variants {
				cc.Format("tag%s tag = iota", code_collector.Capitalize(variant.Name)).LF()
			}
			return cc
		}).
		Format(`
type %s struct {
    %s%s
    tag tag
}`, templateData.EnumDefName, templateData.Package, code_collector.Bracket(templateData.UseTypeParams)).LF().
		Func(func(cc *code_collector.CodeCollector) *code_collector.CodeCollector {
			for _, variant := range templateData.Variants {
				cc.Tmpl(`
func New{{ .FieldName | capitalize }}{{ .DefTypeParams | bracket }}({{ if .HasData }}v {{ .TypeName }}{{ end }}) {{ .EnumUseName }} {
	return {{ .EnumUseName }}{
			{{ .Package }}: {{ .Package }}{{ .UseTypeParams | bracket }}{
					{{ .FieldName }}: {{ if .HasData }}v{{ else }}nil{{ end }},
			},
			tag: tag{{ .FieldName | capitalize }},
	}
}`, struct {
					Package       string
					FieldName     string
					TypeName      string
					HasData       bool
					DefTypeParams string
					EnumUseName   string
					UseTypeParams string
				}{
					Package:       templateData.Package,
					FieldName:     variant.FieldName,
					TypeName:      variant.TypeName,
					HasData:       variant.HasData,
					DefTypeParams: templateData.DefTypeParams,
					EnumUseName:   templateData.EnumUseName,
					UseTypeParams: templateData.UseTypeParams,
				})
			}
			return cc
		}).LF().
		Func(func(cc *code_collector.CodeCollector) *code_collector.CodeCollector {
			for _, variant := range templateData.Variants {
				cc.Tmpl(`
func (e *{{ .EnumUseName }}) Is{{ .Name }}() bool {
	return e.tag == tag{{ .Name }}
}`, struct {
					EnumUseName string
					Name        string
				}{EnumUseName: templateData.EnumUseName, Name: code_collector.Capitalize(variant.Name)})
			}
			return cc
		}).LF().
		Func(func(cc *code_collector.CodeCollector) *code_collector.CodeCollector {
			for _, variant := range templateData.Variants {
				if variant.HasData {
					cc.Tmpl(`
func (e *{{ .EnumUseName }}) As{{ .FieldName | capitalize }}() ({{ .TypeName }}, bool) {
	if e.Is{{ .FieldName | capitalize }}() {
		return e.{{ .Package }}.{{ .FieldName }}, true
	}
	return nil, false
}`, struct {
						Package     string
						EnumUseName string
						FieldName   string
						TypeName    string
					}{
						Package:     templateData.Package,
						EnumUseName: templateData.EnumUseName,
						FieldName:   variant.FieldName,
						TypeName:    variant.TypeName,
					})
				}
			}
			return cc
		}).LF().
		Tmpl(`
type Switcher{{.DefTypeParams | bracket}} struct {
	{{- range $variant := .Variants }}
		{{ $variant.Name | capitalize }} func({{ if $variant.HasData }}v {{ $variant.TypeName }}{{ end }})
	{{- end }}
}

func (e *{{ $.EnumUseName }}) Switch(s Switcher{{.UseTypeParams | bracket}}) {
    switch e.tag {
    {{- range $variant := .Variants }}
			case tag{{ $variant.Name | capitalize }}:
				{{- if $variant.HasData }}
				s.{{ $variant.Name | capitalize }}(e.{{ $.Package }}.{{ $variant.FieldName }})
				{{- else }}
				s.{{ $variant.Name | capitalize }}()
				{{- end }}
    {{- end }}
    }
}`, struct {
			Package       string
			EnumUseName   string
			Variants      []Variant
			DefTypeParams string
			UseTypeParams string
		}{Package: templateData.Package, EnumUseName: templateData.EnumUseName, Variants: templateData.Variants, DefTypeParams: templateData.DefTypeParams, UseTypeParams: templateData.UseTypeParams}).LF().
		Tmpl(`
type Matcher[MatchResult any {{.DefTypeParams | csvConnect}}] struct {
{{- range $variant := .Variants }}
    {{ $variant.Name | capitalize }} func({{ if $variant.HasData }}v {{ $variant.TypeName }}{{ end }}) MatchResult
{{- end }}
}

func Match[MatchResult any {{.DefTypeParams | csvConnect}}](e *{{ .EnumUseName }}, m Matcher[MatchResult {{.UseTypeParams | csvConnect}}]) MatchResult {
    switch e.tag {
    {{- range $variant := .Variants }}
			case tag{{ $variant.Name | capitalize }}:
				{{- if $variant.HasData }}
				return m.{{ $variant.Name | capitalize }}(e.{{ $.Package }}.{{ $variant.FieldName }})
				{{- else }}
				return m.{{ $variant.Name | capitalize }}()
				{{- end }}
    {{- end }}
    }
    panic("unreachable: invalid tag")
}`, struct {
			Package       string
			EnumUseName   string
			Variants      []Variant
			DefTypeParams string
			UseTypeParams string
		}{Package: templateData.Package, EnumUseName: templateData.EnumUseName, Variants: templateData.Variants, DefTypeParams: templateData.DefTypeParams, UseTypeParams: templateData.UseTypeParams}).LF()

	generated, err := cc.Export()
	if err != nil {
		return nil, err
	}

	return generated, nil
}
