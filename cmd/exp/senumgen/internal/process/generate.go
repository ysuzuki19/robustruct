package process

import (
	"fmt"
	"strings"

	"github.com/ysuzuki19/robustruct/cmd/exp/senumgen/internal/process/coder"
)

type GenerateArgs struct {
	DirPath       string
	Name          string
	AnalyzeResult AnalyzeResult
}

func Generate(args GenerateArgs) ([]byte, error) {
	defTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return fmt.Sprintf("%s %s", tp.Name, tp.TypeName)
		}),
		", ",
	)

	useTypeParams := strings.Join(
		args.AnalyzeResult.TypeParams.Map(func(tp TypeParam) string {
			return tp.Name
		}),
		", ",
	)

	name := args.Name
	enumDefName := fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), coder.Bracket(defTypeParams))
	enumUseName := fmt.Sprintf("%sEnum%s", strings.ToLower(args.Name), coder.Bracket(useTypeParams))
	valueReceiver := fmt.Sprintf("(e *%s)", enumUseName)
	pointerReceiver := fmt.Sprintf("(e *%s)", enumUseName)
	variants := args.AnalyzeResult.Variants

	c := coder.New().Globals(coder.Vars{
		"name":            name,
		"DefTypeParams":   defTypeParams,
		"UseTypeParams":   useTypeParams,
		"EnumDefName":     enumDefName,
		"EnumUseName":     enumUseName,
		"ValueReceiver":   valueReceiver,
		"PointerReceiver": pointerReceiver,
	})

	c.
		// package declaration
		Str(`// Code generated by senum; DO NOT EDIT.`).LF().
		Format(`package %s`, name).LF().

		// enum tag
		Str(`type tag int`).LF().
		Wrap("const (", ")", func() {
			for _, variant := range variants {
				c.Format("tag%s tag = iota", coder.Capitalize(variant.Name)).LF()
			}
		}).LF().
		Tmpl(`
		type {{.EnumDefName}} struct {
			{{.name}}{{.UseTypeParams|bracket}}
			tag tag
		}
		`).

		// enum constructor
		Fn(func() {
			for _, variant := range variants {
				c.Tmpl(`
				func New{{ .FieldName | capitalize }}{{ .DefTypeParams | bracket }}({{ if .HasData }}v {{ .TypeName }}{{ end }}) {{ .EnumUseName }} {
					return {{ .EnumUseName }}{
							{{ .name }}: {{ .name }}{{ .UseTypeParams | bracket }}{
									{{ .FieldName }}: {{ if .HasData }}v{{ else }}nil{{ end }},
							},
							tag: tag{{ .FieldName | capitalize }},
					}
				}
				`, coder.Vars{
					"FieldName": variant.FieldName,
					"TypeName":  variant.TypeName,
					"HasData":   variant.HasData,
				})
			}
		}).

		// enum Is{FieldName} method
		Fn(func() {
			for _, variant := range variants {
				c.Tmpl(`
				func {{ .PointerReceiver }} Is{{ .FieldName }}() bool {
					return e.tag == tag{{ .FieldName }}
				}
				`, coder.Vars{
					"FieldName": coder.Capitalize(variant.Name),
				})
			}
		}).LF().

		// enum As{FieldName} method
		Fn(func() {
			for _, variant := range variants {
				if variant.HasData {
					c.Tmpl(`
					func {{ .PointerReceiver }} As{{ .FieldName | capitalize }}() ({{ .TypeName }}, bool) {
						if e.Is{{ .FieldName | capitalize }}() {
							return e.{{ .name }}.{{ .FieldName }}, true
						}
						return nil, false
					}
					`, coder.Vars{
						"FieldName": variant.FieldName,
						"TypeName":  variant.TypeName,
					})
				}
			}
		}).LF().

		// enum Switcher struct
		Tmpl(`type Switcher{{.DefTypeParams|bracket}} struct`).
		Block(func() {
			for _, variant := range variants {
				c.LF().Format(" %s func", coder.Capitalize(variant.Name)).Parens(func() {
					if variant.HasData {
						c.Str("v " + variant.TypeName)
					}
				})
			}
		}).LF().

		// enum Switch method
		Tmpl(`func{{ .PointerReceiver }}Switch`).
		Parens(func() {
			c.Tmpl("s Switcher{{.UseTypeParams|bracket}}")
		}).
		Block(func() {
			c.Str("switch e.tag").Braces(func() {
				for _, variant := range variants {
					c.LF().Format("case tag%s:", coder.Capitalize(variant.Name))
					if variant.HasData {
						c.Str("s.").Capitalize(variant.Name).Parens(func() {
							c.Format("e.%s.%s", name, variant.FieldName)
						})
					} else {
						c.Str("s.").Capitalize(variant.Name).Str("()")
					}
				}
			})
		}).LF().

		// Matcher struct
		Tmpl(`type Matcher[MatchResult any {{.DefTypeParams | csvConnect}}] struct`).
		Block(func() {
			for _, variant := range variants {
				c.Format("%s func", coder.Capitalize(variant.Name)).Parens(func() {
					if variant.HasData {
						c.Str("v " + variant.TypeName)
					}
				}).Str(" MatchResult").LF()
			}
		}).LF().
		Tmpl(`func Match[MatchResult any {{.DefTypeParams | csvConnect}}](e *{{ .EnumUseName }}, m Matcher[MatchResult {{.UseTypeParams | csvConnect}}]) MatchResult`).
		Block(func() {
			c.Format("switch e.tag").Braces(func() {
				for _, variant := range variants {
					c.
						Format("case tag%s:", coder.Capitalize(variant.Name)).
						Format("return m.%s", coder.Capitalize(variant.Name)).Parens(func() {
						if variant.HasData {
							c.Format("e.%s.%s", name, variant.FieldName)
						}
					}).LF()
				}
			}).LF().Str("panic(\"unreachable: invalid tag\")")
		})

	generated, err := c.Export()
	if err != nil {
		return nil, err
	}
	fmt.Println(string(generated))

	return generated, nil
}
